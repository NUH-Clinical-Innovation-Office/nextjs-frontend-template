name: Staging Deploy

on:
  workflow_call:
    inputs:
      image_tag:
        description: "Docker image tag to deploy"
        required: true
        type: string

env:
  NODE_VERSION: "24.10.0"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  STAGING_PORT: 30002

jobs:
  deploy:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://${{ github.event.repository.name }}-staging.${{ vars.CLOUDFLARE_DOMAIN }}
    permissions:
      contents: read
      packages: read
      deployments: write
      security-events: write
    outputs:
      deployment_url: https://${{ github.event.repository.name }}-staging.${{ vars.CLOUDFLARE_DOMAIN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          MISSING_SECRETS=()

          if [ -z "${{ secrets.KUBECONFIG_STAGING }}" ]; then
            MISSING_SECRETS+=("KUBECONFIG_STAGING")
          fi
          if [ -z "${{ secrets.CLOUDFLARE_API_TOKEN }}" ]; then
            MISSING_SECRETS+=("CLOUDFLARE_API_TOKEN")
          fi
          if [ -z "${{ secrets.CLOUDFLARE_ACCOUNT_ID }}" ]; then
            MISSING_SECRETS+=("CLOUDFLARE_ACCOUNT_ID")
          fi
          if [ -z "${{ secrets.CLOUDFLARE_TUNNEL_ID }}" ]; then
            MISSING_SECRETS+=("CLOUDFLARE_TUNNEL_ID")
          fi
          if [ -z "${{ vars.CLOUDFLARE_DOMAIN }}" ]; then
            MISSING_SECRETS+=("CLOUDFLARE_DOMAIN")
          fi

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "✗ ERROR: Missing required secrets:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            echo ""
            echo "Please configure these secrets in your repository settings."
            exit 1
          fi

          echo "✓ All required secrets are configured"

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: "v3.13.0"

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Convert image name to lowercase
        id: image-name
        run: |
          IMAGE_NAME_LOWER=$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]')
          echo "IMAGE_NAME_LOWER=$IMAGE_NAME_LOWER" >> $GITHUB_OUTPUT

      - name: Pull Docker image for scanning
        run: docker pull ${{ env.REGISTRY }}/${{ steps.image-name.outputs.IMAGE_NAME_LOWER }}:${{ inputs.image_tag }}

      - name: Run Trivy vulnerability scanner on image
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.REGISTRY }}/${{ steps.image-name.outputs.IMAGE_NAME_LOWER }}:${{ inputs.image_tag }}
          format: 'sarif'
          output: 'trivy-image-results.sarif'
          severity: 'CRITICAL,HIGH'
          scan-type: 'image'

      - name: Upload Trivy image results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-image-results.sarif'

      - name: Run Trivy scan with table output
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.REGISTRY }}/${{ steps.image-name.outputs.IMAGE_NAME_LOWER }}:${{ inputs.image_tag }}
          format: 'table'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'
          scan-type: 'image'

      - name: Setup Kubernetes config
        env:
          KUBECONFIG_CONTENT: ${{ secrets.KUBECONFIG_STAGING }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBECONFIG_CONTENT" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Copy GHCR secret to staging namespace
        run: |
          # Create namespace if it doesn't exist
          kubectl create namespace ${{ github.event.repository.name }}-staging --dry-run=client -o yaml | kubectl apply -f -

          # Copy ghcr-secret from main namespace to staging namespace only if it doesn't exist
          if ! kubectl get secret ghcr-secret -n ${{ github.event.repository.name }}-staging &>/dev/null; then
            kubectl get secret ghcr-secret -n ${{ github.event.repository.name }} -o yaml | \
              sed "s/namespace: ${{ github.event.repository.name }}/namespace: ${{ github.event.repository.name }}-staging/" | \
              kubectl apply -f -
            echo "✓ Copied ghcr-secret to ${{ github.event.repository.name }}-staging"
          else
            echo "✓ Secret ghcr-secret already exists in ${{ github.event.repository.name }}-staging"
          fi

      - name: Deploy with Helm
        run: |
          IMAGE_NAME_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')

          helm upgrade --install nextjs-app ./helm/nextjs-app \
            -n ${{ github.event.repository.name }}-staging \
            --create-namespace \
            -f ./helm/nextjs-app/values-staging.yaml \
            --set image.tag=${{ inputs.image_tag }} \
            --set image.repository=${{ env.REGISTRY }}/${IMAGE_NAME_LOWER} \
            --set service.nodePort=${{ env.STAGING_PORT }} \
            --wait \
            --timeout 10m

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/nextjs-app -n ${{ github.event.repository.name }}-staging --timeout=1m

      - name: Create Cloudflare Tunnel route
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CLOUDFLARE_TUNNEL_ID: ${{ secrets.CLOUDFLARE_TUNNEL_ID }}
          CLOUDFLARE_DOMAIN: ${{ vars.CLOUDFLARE_DOMAIN }}
          REPOSITORY_NAME: ${{ github.event.repository.name }}
        run: |
          PORT="${{ env.STAGING_PORT }}"
          FULL_HOSTNAME="${REPOSITORY_NAME}-staging.${CLOUDFLARE_DOMAIN}"

          echo "Adding Cloudflare tunnel route for: $FULL_HOSTNAME -> http://localhost:${PORT}"

          # Get current tunnel configuration
          CURRENT_CONFIG=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/cfd_tunnel/$CLOUDFLARE_TUNNEL_ID/configurations" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")

          # Check if we got a valid response
          if ! echo "$CURRENT_CONFIG" | jq -e '.success == true' >/dev/null 2>&1; then
            echo "✗ Failed to get current tunnel configuration"
            echo "$CURRENT_CONFIG" | jq '.'
            exit 1
          fi

          # Extract current ingress rules
          CURRENT_INGRESS=$(echo "$CURRENT_CONFIG" | jq '.result.config.ingress // []')

          # Remove any existing entry for this hostname (if redeploying)
          CURRENT_INGRESS=$(echo "$CURRENT_INGRESS" | jq --arg hostname "$FULL_HOSTNAME" '
            map(select(.hostname != $hostname))
          ')

          # Add the new route before the catch-all rule
          NEW_INGRESS=$(echo "$CURRENT_INGRESS" | jq --arg hostname "$FULL_HOSTNAME" --arg service "http://localhost:${PORT}" '
            # Remove catch-all if present
            map(select(.service != "http_status:404")) +
            # Add new route
            [{
              "hostname": $hostname,
              "service": $service
            }] +
            # Add catch-all at the end
            [{"service": "http_status:404"}]
          ')

          # Update tunnel configuration with new ingress rules
          UPDATE_RESPONSE=$(curl -s -X PUT \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/cfd_tunnel/$CLOUDFLARE_TUNNEL_ID/configurations" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "{\"config\": {\"ingress\": $NEW_INGRESS}}")

          if echo "$UPDATE_RESPONSE" | jq -e '.success == true' >/dev/null 2>&1; then
            echo "✓ Successfully added tunnel route for $FULL_HOSTNAME"
            echo "Current routes:"
            echo "$NEW_INGRESS" | jq -r '.[] | select(.hostname) | "  - \(.hostname) -> \(.service)"'
          else
            echo "✗ Failed to update tunnel configuration"
            echo "$UPDATE_RESPONSE" | jq '.'
            exit 1
          fi

      - name: Create Cloudflare DNS record
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_TUNNEL_ID: ${{ secrets.CLOUDFLARE_TUNNEL_ID }}
          CLOUDFLARE_DOMAIN: ${{ vars.CLOUDFLARE_DOMAIN }}
          REPOSITORY_NAME: ${{ github.event.repository.name }}
        run: |
          FULL_HOSTNAME="${REPOSITORY_NAME}-staging.${CLOUDFLARE_DOMAIN}"

          echo "Creating DNS CNAME record for: $FULL_HOSTNAME"

          # Get Zone ID for the domain
          ZONE_RESPONSE=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/zones?name=${CLOUDFLARE_DOMAIN}" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")

          ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id')

          if [ -z "$ZONE_ID" ] || [ "$ZONE_ID" = "null" ]; then
            echo "✗ Failed to get Zone ID for domain: $CLOUDFLARE_DOMAIN"
            echo "$ZONE_RESPONSE" | jq '.'
            exit 1
          fi

          echo "✓ Found Zone ID: $ZONE_ID"

          # Check if DNS record already exists
          EXISTING_RECORD=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?type=CNAME&name=${FULL_HOSTNAME}" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")

          RECORD_ID=$(echo "$EXISTING_RECORD" | jq -r '.result[0].id // empty')

          if [ -n "$RECORD_ID" ]; then
            echo "✓ DNS record already exists, updating it"
            UPDATE_RESPONSE=$(curl -s -X PUT \
              "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$RECORD_ID" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{
                \"type\": \"CNAME\",
                \"name\": \"${FULL_HOSTNAME}\",
                \"content\": \"${CLOUDFLARE_TUNNEL_ID}.cfargotunnel.com\",
                \"ttl\": 1,
                \"proxied\": true
              }")

            if echo "$UPDATE_RESPONSE" | jq -e '.success == true' >/dev/null 2>&1; then
              echo "✓ Successfully updated DNS record for $FULL_HOSTNAME"
            else
              echo "✗ Failed to update DNS record"
              echo "$UPDATE_RESPONSE" | jq '.'
              exit 1
            fi
          else
            echo "Creating new DNS record"
            CREATE_RESPONSE=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{
                \"type\": \"CNAME\",
                \"name\": \"${FULL_HOSTNAME}\",
                \"content\": \"${CLOUDFLARE_TUNNEL_ID}.cfargotunnel.com\",
                \"ttl\": 1,
                \"proxied\": true
              }")

            if echo "$CREATE_RESPONSE" | jq -e '.success == true' >/dev/null 2>&1; then
              echo "✓ Successfully created DNS record for $FULL_HOSTNAME"
            else
              echo "✗ Failed to create DNS record"
              echo "$CREATE_RESPONSE" | jq '.'
              exit 1
            fi
          fi
