name: Production Deploy

on:
  workflow_call:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string

env:
  NODE_VERSION: "24.10.0"
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  PRODUCTION_PORT: 30001

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://${{ github.event.repository.name }}.${{ vars.CLOUDFLARE_DOMAIN }}
    permissions:
      contents: read
      deployments: write
    outputs:
      deployment_url: https://${{ github.event.repository.name }}.${{ vars.CLOUDFLARE_DOMAIN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          MISSING_SECRETS=()

          if [ -z "${{ secrets.KUBECONFIG }}" ]; then
            MISSING_SECRETS+=("KUBECONFIG")
          fi
          if [ -z "${{ secrets.CLOUDFLARE_API_TOKEN }}" ]; then
            MISSING_SECRETS+=("CLOUDFLARE_API_TOKEN")
          fi
          if [ -z "${{ secrets.CLOUDFLARE_ACCOUNT_ID }}" ]; then
            MISSING_SECRETS+=("CLOUDFLARE_ACCOUNT_ID")
          fi
          if [ -z "${{ secrets.CLOUDFLARE_TUNNEL_ID }}" ]; then
            MISSING_SECRETS+=("CLOUDFLARE_TUNNEL_ID")
          fi
          if [ -z "${{ vars.CLOUDFLARE_DOMAIN }}" ]; then
            MISSING_SECRETS+=("CLOUDFLARE_DOMAIN")
          fi

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "✗ ERROR: Missing required secrets:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            echo ""
            echo "Please configure these secrets in your repository settings."
            exit 1
          fi

          echo "✓ All required secrets are configured"

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: "v3.13.0"

      - name: Setup Kubernetes config
        env:
          KUBECONFIG_CONTENT: ${{ secrets.KUBECONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBECONFIG_CONTENT" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Ensure namespace exists
        run: |
          # Create namespace if it doesn't exist
          kubectl create namespace ${{ github.event.repository.name }} --dry-run=client -o yaml | kubectl apply -f -
          echo "✓ Namespace ${{ github.event.repository.name }} ready"

      - name: Deploy with Helm
        run: |
          IMAGE_NAME_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')

          helm upgrade --install nextjs-app ./helm/nextjs-app \
            -n ${{ github.event.repository.name }} \
            --create-namespace \
            -f ./helm/nextjs-app/values-production.yaml \
            --set image.tag=${{ inputs.image_tag }} \
            --set image.repository=${{ env.REGISTRY }}/${IMAGE_NAME_LOWER} \
            --set service.nodePort=${{ env.PRODUCTION_PORT }} \
            --wait \
            --timeout 10m

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/nextjs-app -n ${{ github.event.repository.name }} --timeout=1m

      - name: Create Cloudflare Tunnel route
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CLOUDFLARE_TUNNEL_ID: ${{ secrets.CLOUDFLARE_TUNNEL_ID }}
          CLOUDFLARE_DOMAIN: ${{ vars.CLOUDFLARE_DOMAIN }}
        run: |
          PORT="${{ env.PRODUCTION_PORT }}"
          FULL_HOSTNAME="${CLOUDFLARE_DOMAIN}"

          echo "Adding Cloudflare tunnel route for: $FULL_HOSTNAME -> http://localhost:${PORT}"

          # Get current tunnel configuration
          CURRENT_CONFIG=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/cfd_tunnel/$CLOUDFLARE_TUNNEL_ID/configurations" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")

          # Check if we got a valid response
          if ! echo "$CURRENT_CONFIG" | jq -e '.success == true' >/dev/null 2>&1; then
            echo "✗ Failed to get current tunnel configuration"
            echo "$CURRENT_CONFIG" | jq '.'
            exit 1
          fi

          # Extract current ingress rules
          CURRENT_INGRESS=$(echo "$CURRENT_CONFIG" | jq '.result.config.ingress // []')

          # Remove any existing entry for this hostname (if redeploying)
          CURRENT_INGRESS=$(echo "$CURRENT_INGRESS" | jq --arg hostname "$FULL_HOSTNAME" '
            map(select(.hostname != $hostname))
          ')

          # Add the new route before the catch-all rule
          NEW_INGRESS=$(echo "$CURRENT_INGRESS" | jq --arg hostname "$FULL_HOSTNAME" --arg service "http://localhost:${PORT}" '
            # Remove catch-all if present
            map(select(.service != "http_status:404")) +
            # Add new route
            [{
              "hostname": $hostname,
              "service": $service
            }] +
            # Add catch-all at the end
            [{"service": "http_status:404"}]
          ')

          # Update tunnel configuration with new ingress rules
          UPDATE_RESPONSE=$(curl -s -X PUT \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/cfd_tunnel/$CLOUDFLARE_TUNNEL_ID/configurations" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json" \
            --data "{\"config\": {\"ingress\": $NEW_INGRESS}}")

          if echo "$UPDATE_RESPONSE" | jq -e '.success == true' >/dev/null 2>&1; then
            echo "✓ Successfully added tunnel route for $FULL_HOSTNAME"
            echo "Current routes:"
            echo "$NEW_INGRESS" | jq -r '.[] | select(.hostname) | "  - \(.hostname) -> \(.service)"'
          else
            echo "✗ Failed to update tunnel configuration"
            echo "$UPDATE_RESPONSE" | jq '.'
            exit 1
          fi

      - name: Create Cloudflare DNS record
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_TUNNEL_ID: ${{ secrets.CLOUDFLARE_TUNNEL_ID }}
          CLOUDFLARE_DOMAIN: ${{ vars.CLOUDFLARE_DOMAIN }}
        run: |
          FULL_HOSTNAME="${CLOUDFLARE_DOMAIN}"

          echo "Creating DNS A/CNAME record for: $FULL_HOSTNAME"

          # Get Zone ID for the domain
          ZONE_RESPONSE=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/zones?name=${CLOUDFLARE_DOMAIN}" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")

          ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id')

          if [ -z "$ZONE_ID" ] || [ "$ZONE_ID" = "null" ]; then
            echo "✗ Failed to get Zone ID for domain: $CLOUDFLARE_DOMAIN"
            echo "$ZONE_RESPONSE" | jq '.'
            exit 1
          fi

          echo "✓ Found Zone ID: $ZONE_ID"

          # Check if DNS record already exists
          EXISTING_RECORD=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?type=CNAME&name=${FULL_HOSTNAME}" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")

          RECORD_ID=$(echo "$EXISTING_RECORD" | jq -r '.result[0].id // empty')

          if [ -n "$RECORD_ID" ]; then
            echo "✓ DNS record already exists, updating it"
            UPDATE_RESPONSE=$(curl -s -X PUT \
              "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$RECORD_ID" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{
                \"type\": \"CNAME\",
                \"name\": \"${FULL_HOSTNAME}\",
                \"content\": \"${CLOUDFLARE_TUNNEL_ID}.cfargotunnel.com\",
                \"ttl\": 1,
                \"proxied\": true
              }")

            if echo "$UPDATE_RESPONSE" | jq -e '.success == true' >/dev/null 2>&1; then
              echo "✓ Successfully updated DNS record for $FULL_HOSTNAME"
            else
              echo "✗ Failed to update DNS record"
              echo "$UPDATE_RESPONSE" | jq '.'
              exit 1
            fi
          else
            echo "Creating new DNS record"
            CREATE_RESPONSE=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{
                \"type\": \"CNAME\",
                \"name\": \"${FULL_HOSTNAME}\",
                \"content\": \"${CLOUDFLARE_TUNNEL_ID}.cfargotunnel.com\",
                \"ttl\": 1,
                \"proxied\": true
              }")

            if echo "$CREATE_RESPONSE" | jq -e '.success == true' >/dev/null 2>&1; then
              echo "✓ Successfully created DNS record for $FULL_HOSTNAME"
            else
              echo "✗ Failed to create DNS record"
              echo "$CREATE_RESPONSE" | jq '.'
              exit 1
            fi
          fi

      - name: Create GitHub Deployment
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: 'production',
              auto_merge: false,
              required_contexts: []
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'success',
              environment_url: 'https://${{ vars.CLOUDFLARE_DOMAIN }}',
              description: 'Production deployment successful'
            });
