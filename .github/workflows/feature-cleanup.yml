name: Feature Branch Cleanup

on:
  delete:

env:
  PORT_MAPPING_NAMESPACE: default

jobs:
  cleanup:
    name: Cleanup Feature Branch Deployment
    runs-on: ubuntu-latest
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          MISSING_SECRETS=()

          if [ -z "${{ secrets.KUBECONFIG }}" ]; then
            MISSING_SECRETS+=("KUBECONFIG")
          fi

          # Cloudflare secrets are optional since the step is conditional
          # but we'll warn if they're missing
          if [ -z "${{ secrets.CLOUDFLARE_API_TOKEN }}" ]; then
            echo "⚠ WARNING: CLOUDFLARE_API_TOKEN is not set. Cloudflare cleanup will be skipped."
          fi

          if [ ${#MISSING_SECRETS[@]} -gt 0 ]; then
            echo "✗ ERROR: Missing required secrets:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            echo ""
            echo "Please configure these secrets in your repository settings."
            exit 1
          fi

          echo "✓ All required secrets are configured"

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: "v3.13.0"

      - name: Setup Kubernetes config
        env:
          KUBECONFIG_CONTENT: ${{ secrets.KUBECONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBECONFIG_CONTENT" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Determine branch name
        id: branch-name
        run: |
          if [ "${{ github.event_name }}" == "delete" ]; then
            BRANCH_NAME="${{ github.event.ref }}"
          else
            BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          fi
          SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/\//-/g' | tr '[:upper:]' '[:lower:]')
          echo "SANITIZED=$SANITIZED_BRANCH" >> $GITHUB_OUTPUT

      - name: Get allocated port
        id: get-port
        run: |
          PORT=$(kubectl get configmap feature-branch-port-mappings -n ${{ env.PORT_MAPPING_NAMESPACE }} \
            -o jsonpath="{.data.${{ steps.branch-name.outputs.SANITIZED }}}" 2>/dev/null || echo "")
          echo "PORT=$PORT" >> $GITHUB_OUTPUT

      - name: Delete Helm release
        run: |
          NAMESPACE="nextjs-${{ steps.branch-name.outputs.SANITIZED }}"

          if helm list -n "$NAMESPACE" | grep -q "nextjs-app-${{ steps.branch-name.outputs.SANITIZED }}"; then
            echo "Deleting Helm release..."
            helm uninstall nextjs-app-${{ steps.branch-name.outputs.SANITIZED }} -n "$NAMESPACE" || true
          else
            echo "No Helm release found, skipping..."
          fi

      - name: Delete namespace
        run: |
          NAMESPACE="nextjs-${{ steps.branch-name.outputs.SANITIZED }}"

          if kubectl get namespace "$NAMESPACE" 2>/dev/null; then
            echo "Deleting namespace $NAMESPACE..."
            kubectl delete namespace "$NAMESPACE" --timeout=2m || true
          else
            echo "Namespace not found, skipping..."
          fi

      - name: Remove port mapping
        run: |
          kubectl patch configmap feature-branch-port-mappings -n ${{ env.PORT_MAPPING_NAMESPACE }} \
            --type json \
            -p "[{\"op\": \"remove\", \"path\": \"/data/${{ steps.branch-name.outputs.SANITIZED }}\"}]" || echo "Port mapping not found or already removed"

      - name: Remove Cloudflare Tunnel route
        if: steps.get-port.outputs.PORT != ''
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          CLOUDFLARE_TUNNEL_ID: ${{ secrets.CLOUDFLARE_TUNNEL_ID }}
          CLOUDFLARE_DOMAIN: ${{ vars.CLOUDFLARE_DOMAIN }}
        run: |
          SUBDOMAIN="${{ steps.branch-name.outputs.SANITIZED }}"
          FULL_HOSTNAME="${SUBDOMAIN}-dev-${{ github.event.repository.name }}.${CLOUDFLARE_DOMAIN}"

          echo "Attempting to remove Cloudflare tunnel route for: $FULL_HOSTNAME"

          # Get current tunnel configuration
          CURRENT_CONFIG=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/cfd_tunnel/$CLOUDFLARE_TUNNEL_ID/configurations" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")

          # Check if we got a valid response
          if echo "$CURRENT_CONFIG" | jq -e '.success == true' >/dev/null 2>&1; then
            # Extract current ingress rules and remove the matching hostname
            NEW_INGRESS=$(echo "$CURRENT_CONFIG" | jq --arg hostname "$FULL_HOSTNAME" '
              .result.config.ingress |
              map(select(.hostname != $hostname))
            ')

            # Ensure we always have the catch-all rule at the end
            HAS_CATCHALL=$(echo "$NEW_INGRESS" | jq 'any(.service == "http_status:404")')
            if [ "$HAS_CATCHALL" != "true" ]; then
              NEW_INGRESS=$(echo "$NEW_INGRESS" | jq '. + [{"service": "http_status:404"}]')
            fi

            # Update tunnel configuration with cleaned ingress rules
            UPDATE_RESPONSE=$(curl -s -X PUT \
              "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/cfd_tunnel/$CLOUDFLARE_TUNNEL_ID/configurations" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{\"config\": {\"ingress\": $NEW_INGRESS}}")

            if echo "$UPDATE_RESPONSE" | jq -e '.success == true' >/dev/null 2>&1; then
              echo "✓ Successfully removed tunnel route for $FULL_HOSTNAME"
            else
              echo "✗ Failed to update tunnel configuration"
              echo "$UPDATE_RESPONSE" | jq '.'
              echo "⚠ WARNING: Cloudflare route cleanup failed. Manual cleanup may be required."
              echo "⚠ Orphaned route: $FULL_HOSTNAME"
            fi
          else
            echo "✗ Failed to get current tunnel configuration"
            echo "$CURRENT_CONFIG" | jq '.'
            echo "⚠ WARNING: Cloudflare route cleanup failed. Manual cleanup may be required."
            echo "⚠ Orphaned route: $FULL_HOSTNAME"
          fi

      - name: Remove Cloudflare DNS record
        if: steps.get-port.outputs.PORT != ''
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_DOMAIN: ${{ vars.CLOUDFLARE_DOMAIN }}
        run: |
          SUBDOMAIN="${{ steps.branch-name.outputs.SANITIZED }}"
          FULL_HOSTNAME="${SUBDOMAIN}-dev-${{ github.event.repository.name }}.${CLOUDFLARE_DOMAIN}"

          echo "Attempting to remove Cloudflare DNS record for: $FULL_HOSTNAME"

          # Get Zone ID for the domain
          ZONE_RESPONSE=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/zones?name=${CLOUDFLARE_DOMAIN}" \
            -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
            -H "Content-Type: application/json")

          ZONE_ID=$(echo "$ZONE_RESPONSE" | jq -r '.result[0].id')

          if [ -z "$ZONE_ID" ] || [ "$ZONE_ID" = "null" ]; then
            echo "⚠ WARNING: Could not get Zone ID for domain: $CLOUDFLARE_DOMAIN"
            echo "$ZONE_RESPONSE" | jq '.'
          else
            # Check if DNS record exists
            EXISTING_RECORD=$(curl -s -X GET \
              "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records?type=CNAME&name=${FULL_HOSTNAME}" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json")

            RECORD_ID=$(echo "$EXISTING_RECORD" | jq -r '.result[0].id // empty')

            if [ -n "$RECORD_ID" ]; then
              DELETE_RESPONSE=$(curl -s -X DELETE \
                "https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$RECORD_ID" \
                -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
                -H "Content-Type: application/json")

              if echo "$DELETE_RESPONSE" | jq -e '.success == true' >/dev/null 2>&1; then
                echo "✓ Successfully removed DNS record for $FULL_HOSTNAME"
              else
                echo "⚠ WARNING: Failed to delete DNS record"
                echo "$DELETE_RESPONSE" | jq '.'
              fi
            else
              echo "✓ DNS record not found (may have been already removed)"
            fi
          fi

      - name: Deactivate GitHub deployment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const branchName = context.payload.pull_request.head.ref;
            const environmentName = `preview-${branchName}`;

            try {
              // Get all deployments for this environment
              const { data: deployments } = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                environment: environmentName
              });

              // Mark all deployments as inactive
              for (const deployment of deployments) {
                await github.rest.repos.createDeploymentStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: deployment.id,
                  state: 'inactive'
                });

                console.log(`✓ Deactivated deployment ${deployment.id}`);
              }

              console.log(`✓ Cleaned up ${deployments.length} deployment(s) for environment: ${environmentName}`);
            } catch (error) {
              console.log(`⚠ Warning: Could not deactivate deployments: ${error.message}`);
            }
